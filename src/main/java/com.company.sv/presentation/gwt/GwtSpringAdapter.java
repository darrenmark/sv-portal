package com.company.sv.presentation.gwt;

import com.google.gwt.user.client.rpc.IncompatibleRemoteServiceException;
import com.google.gwt.user.client.rpc.RemoteService;
import com.google.gwt.user.client.rpc.SerializationException;
import com.google.gwt.user.server.rpc.RPC;
import com.google.gwt.user.server.rpc.RPCRequest;
import com.google.gwt.user.server.rpc.RemoteServiceServlet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;
import org.springframework.web.context.ServletContextAware;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

/**
 * A Spring controller that is capable of receiving requests in the GWT RPC format and automatically mapping them onto
 * implementations registered in the Spring container.
 * <p/>
 * To implement a GWT RPC call the client RPC interface and it's Async should be declared in the usual way but the
 * RPC interface should have its path set with the attribute @RemoteServiceRelativePath to end in .rpc,
 * e.g. @RemoteServiceRelativePath("attributesService.rpc").
 * <p/>
 * The .rpc URL is mapped through to this controller (in spring-config-controller.xml), which will look for a concrete
 * implementation of the interface in Spring and delegate to it.
 */
@Deprecated
@Component
public class GwtSpringAdapter extends RemoteServiceServlet implements Controller, ServletContextAware, ApplicationContextAware {
    private static Logger log = LoggerFactory.getLogger(GwtSpringAdapter.class);
    private ServletContext servletContext;
    private ApplicationContext context;
    private List<String> applicablePackages = Arrays.asList("com.company.sv.presentation.gwt.client");

    /**
     * Convert the GWT client service package names into strings
     * for searching a GWT rpc payload.
     */
    public void init() {
        List<String> tags = new ArrayList<String>();
        for (String startTag : applicablePackages) {
            tags.add(new StringBuilder("|").append(startTag).append(".").toString());
        }
        this.applicablePackages = tags;
    }

    /**
     * Set the GWT client service package names. The package
     * names specify the GWT remote client service packages.
     *
     * @param applicablePackages The list of GWT client service package names.
     */
    @SuppressWarnings("unused")
    public void setApplicablePackages(List<String> applicablePackages) {
        this.applicablePackages = applicablePackages;
    }

    /**
     * Implement the compulsory handleRequest from Controller. This does nothing.
     */
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        //Save the request into this thread so that ServletAware RPC sub-classes can get it
        ServletAware.setHttpServletRequest(request);
        //Call the doPost() in the GWT RemoteServiceServlet super class. This will call our processCall()
        super.doPost(request, response);
        return null;
    }

    /**
     * Override the call processing from the RemoteServiceServlet class to map the request onto a Spring bean. This is
     * where the work is done. GWT's RPC class helps greatly with this.
     */
    @Override
    public String processCall(String payload) throws SerializationException {
        Object rpcImpl = deriveRpcImpl(payload);
        RPCRequest rpcRequest;
        // needed this style of invocation (parse payload, decodeRequest with 3 param signature)
        // to avoid GWT IsSerializable errors.  GWT creates a whitelist
        // of classes it will support in RPCs, if it doesn't recognize something it excepts.  When using
        // Spring complicates this issue
        try {
            rpcRequest = RPC.decodeRequest(payload, rpcImpl.getClass(), this);
        }
        catch(Exception e) {
            // this form needed when client/server package names different than auto-generated by GWT when
            // creating Rpc, RpcAsync, RpcImpl classes/interfaces
            rpcRequest = RPC.decodeRequest(payload, rpcImpl.getClass());
        }

        // Inject servlet context into RPC servlet implementation on behalf of the servlet container.
        if (rpcImpl != null && rpcImpl instanceof ServletContextAware) {
            ((ServletContextAware) rpcImpl).setServletContext(this.servletContext);
        }

        return RPC.invokeAndEncodeResponse(rpcImpl, rpcRequest.getMethod(), rpcRequest.getParameters(), rpcRequest.getSerializationPolicy());
    }

//    @Override
//    public String getServletName() {
//        String servletName=  super.getServletName();
//        return servletName;
//    }

    /**
     * Inject the Spring application context. We will use this to look for beans.
     */
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.context = applicationContext;
    }

    /**
     * Get the servlet context, this is required by the RemoteServiceServlet super class.
     */
    @Override
    public ServletContext getServletContext() {
        return servletContext;
    }

    /**
     * Inject the servlet context.
     */
    public void setServletContext(ServletContext servletContext) {
        this.servletContext = servletContext;
    }
    Object implFromInterface(Class rpcInterface) {
        Map implementations = context.getBeansOfType(rpcInterface);
        if (implementations.size() == 1) {
            return implementations.values().toArray()[0];
        }
        else {
            String msg;
            if (implementations.size() == 0) {
                msg = "Didn't find rpc Spring bean for class: " + rpcInterface;
            }
            else {
                msg = "Found more than 1 rpc Spring bean for class: " + rpcInterface + " implementations: " + implementations.values();
            }
            log.error(msg);
            return null;
        }
    }
    // typical payload:
    // 6|0|4|http://localhost:8080/sc/com.aptare.sc.gwt.admin.Admin/|D731B84D8D7F4EF03F595475D2F85AE4|com.aptare.sc.gwt.admin.client.collectorLogs.CollectorLogsRpc|getList|1|2|3
    Object deriveRpcImpl(String payload) {
        final String endTag = "|";
        int foundCt = 0;
        Class rpcInterfaceClass = null;
        Object rpcImpl = null;
        List<String> foundImplList = new ArrayList<String>();


        for (String startTag : applicablePackages) {
            int start = payload.indexOf(startTag);
            if (start > -1) {
                int end = payload.indexOf(endTag, start + 1);
                if (end  > -1 )  {
                    String  className = payload.substring(start + 1, end + endTag.length() - 1);
                    try {
                        rpcInterfaceClass = Class.forName(className);
                        if (RemoteService.class.isAssignableFrom(rpcInterfaceClass)) {
                            Object tmpRpcImpl = implFromInterface(rpcInterfaceClass);
                            if (tmpRpcImpl != null) {
                                rpcImpl = tmpRpcImpl;
                                foundImplList.add(rpcImpl.getClass().getName());
                                foundCt++;
                            }
                        }
                        else {
                            log.error("Found class: " + className + " but not a RemoteService, skipping");
                        }
                    }
                    catch(ClassNotFoundException e)  {
                        // ignore -  just means parsing found package specifier but it was part of the payload
                    }
                }
            }
        }
        if (foundCt == 1) return rpcImpl;
        else {
            String msg;
            if (foundCt == 0) {
                msg  = "Couldn't find an RemoteService implementation";
            }
            else {
                msg ="Found more than 1 RemoteServiceServlet (" + foundImplList  + ") couldn't process rpc request";
            }
            log.error(msg + " in payload: " + payload);
            throw new IncompatibleRemoteServiceException(msg);
        }
    }
}
